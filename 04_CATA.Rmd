
# Check All That Applies (CATA)

Check All That Apply (CATA) data is in its raw form binary indicating whether a judge finds a product to have the attribute (1) or not (0). 

Usually, such data is organized in a matrix where each row corresponds to the evaluation of one product by one judge. And the coloumns are then the attributes. 

Say you for instance have 26 judges/consummers and 4 products, and further that all products are evaluated by all judges once on 13 attributes. Your data matrix would then have 104 rows and 13 coloums (with responses) and additionally coloumns indicating judge, product, record id, date, etc. 

## An example from Beer profiling 

```{r}
library(data4consumerscience)
library(tidyverse)

data("beercata")
beercata %>% head()
table(beercata$Beer) 
length(unique(beercata$Consumer.ID))

```

## Two versions of the data

- RAW data with each row being responses from one evaluation
- Agglomerated to counts, with each row being one product

[Put in the pictures from Rinnan et al 2015]

The agglomerated version is computed by: 

```{r}
# Questions we want answer using these data
# - Are the products different / similar? 
  # - Which attributes drives discrimination? 
  # - Are there any judges who are really of? 
  
beercatasum <- beercata %>% 
  gather(attrib, val, S_Flowers:S_Vinous) %>% 
  group_by(Beer,attrib) %>%
  dplyr::summarize(n = sum(val)) %>% 
  spread(attrib,n)

beercatasum
```

... and visualized by for instance a barplot. 

```{r}
# summary counts over attrobite
beercatasum %>% 
  gather(attrib, n, S_Flowers:S_Vinous) %>% 
  ggplot(data = ., aes(attrib,n, fill = Beer)) + 
  geom_bar(stat = 'identity', position = position_dodge()) + 
  coord_flip()
```

## PCA 

A PCA on the agglomerated counts, reveal the attributes associated with the individual products:  

```{r}
mdlPCA <- prcomp(beercatasum[,-1], scale. = T)
ggbiplot::ggbiplot(mdlPCA, labels = beercatasum$Beer)
```

The attributes Bean, Caramel, Warming, Aromatic etc is associated to the beer _Brown ale_, while Berrie, Dessert, Pungent, etc. is characteristic of _Wheat IPA_ [Maybe add some more narrative]


## Cochranes Q-test

Cochranes Q-test is a statistical test for the comparison of several products, where the response is binary, and there is repeated responses across several judges. We need a package (_RVAideeeeMemoire_).

For one response variable: _S_Flowers_

```{r}
library(RVAideMemoire)
m <- cochran.qtest(S_Flowers ~ Beer | Consumer.ID,
                   data = beercata)

m
```
The p.value is strongly significant, indicating that we cannot assumme the same level of S_Flower in all beers. I.e. the beers seems different based on this characteristics. This is in agreement with the barplot above, where S_Flower is high in NY Lager and really low for Brown ale.  

### Post hoc contrasts

As we observe differences based on this attribute, we pursue the question on which products sticks out? And are there products which are similar? This is done by pairwise comparisons: 

```{r}
library(rcompanion)
PT = pairwiseMcnemar(S_Flowers ~ Beer | Consumer.ID,
                     data   = beercata,
                     test   = "permutation",
                     method = "fdr",
                     digits = 3)
PT$Pairwise %>% 
  arrange(-abs(as.numeric(Z))) %>% 
  data.frame()
```
The table is sorted with the most different pairs at the top, and the least different at the bottom. Hence most products are different, while _Porse Bock_ and _Ravnsborg Red_ are fairly alike.

### For all Attributes

We use tidyverse and broom for this, but need a function capable of handling Cochranes Q-test outputs.  

```{r}
library(broom)
tidy.RVtest <- function(m){
  r <- data.frame(statistic = m$statistic,df = m$parameter,
                  p.value= m$p.value,
                  method = m$method.test)
  return(r)
}

tb_cochran <- beercata %>% 
  gather(attrib, val, S_Flowers:S_Vinous) %>% 
  group_by(attrib) %>%
  do(cochran.qtest(val ~ Beer | Consumer.ID,
                   data = .) %>% tidy)

tb_cochran %>% 
  arrange(p.value) 
```
This output indicates that _S_Beans_ is the most discriminatory attribute, while _S_Pungent_ is the least. 

### PLSDA

This needs more love. 

```{r}
library(caret)
mdl <- plsda(data.frame(beercata[,3:29]),factor(beercata$Beer),ncomp = 3)

scores <- mdl$scores %>% 
  unclass %>% 
  as.data.frame %>% 
  cbind(beercata)

loadings <- mdl$loadings %>% 
  unclass %>% 
  as.data.frame %>% 
  rownames_to_column('attrib') %>% 
  mutate(attrib2 = substr(attrib,3,50)) # lets remove the S_

g1 <- ggplot(data = loadings, aes(`Comp 1`, `Comp 2`, label = attrib2)) + 
  # geom_point() + 
  geom_text()

g2 <- ggplot(data = scores, aes(`Comp 1`, `Comp 2`, color = Beer)) + 
  # geom_point() + 
  stat_ellipse(level = 0.5)

library(patchwork)
g1 + g2


# do multiple splithalfs
# INPUT: judge id. CATA, class, ncomp
X <- beercata[,3:29]
clss <- factor(beercata$Beer)
judge <- beercata$Consumer.ID
k <- 3
A <- 30

mdl0 <- plsda(X,clss,ncomp = k)
lds0 <- mdl0$loadings %>% 
  unclass %>% 
  as.data.frame %>% 
  rownames_to_column('attrib') %>% 
  gather(cmp,val0,-attrib) 

unjudge <- unique(judge)
nindiv <- length(unjudge)

LOADS <- data.frame()
for (i in 1:A){
  ic <- judge %in% sample(unjudge)[1:round(nindiv/2)]
  mdlSH <- plsda(X[ic,],clss[ic],ncomp = k)
  df_flip <- data.frame(sng = sign(diag(t(mdl0$loadings) %*% mdlSH$loadings))) %>% 
    rownames_to_column('cmp')
  lds <- mdlSH$loadings %>% 
    unclass %>% 
    as.data.frame %>% 
    rownames_to_column('attrib') %>% 
    gather(cmp,val,-attrib) %>% 
    left_join(df_flip, by = 'cmp') %>% 
    mutate(SHiter = i, 
           val = val*sng)  
  
  LOADS <- bind_rows(LOADS,lds)
}
fc <- (1 / A)*((A - 1)/A)
sdloads <- LOADS %>% 
  left_join(lds0, by = c('attrib','cmp')) %>% 
  group_by(attrib,cmp) %>% 
  dplyr::summarise(sd = sum((val-val0)^2) *fc) %>% 
  mutate(cmp = paste('sd',cmp,sep = '')) %>% 
  spread(cmp,sd)

loadsSH <- lds0 %>% 
  spread(cmp,val0) %>% 
  left_join(sdloads, by = 'attrib')

library(ggforce)
ggplot(data = loadsSH, aes(x0 = `Comp 1`,y0 = `Comp 2`,a = `sdComp 1`,b = `sdComp 2`,angle = 0)) + geom_ellipse()
```

```{r}

```

